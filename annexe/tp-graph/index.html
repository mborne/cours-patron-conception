<!doctype html>
<html>

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, minimal-ui">
  <title>tp-graph/index.md</title>
  <link type="text/css" rel="stylesheet" href="../assets/css/github-markdown.css">
  <link type="text/css" rel="stylesheet" href="../assets/css/pilcrow.css">
  <link type="text/css" rel="stylesheet" href="../assets/css/hljs-github.min.css" />

  <link rel="stylesheet" href="../assets/highlight/styles/github.css">
  <style>
    html, body {
      width: 90%;
      margin: auto;
      padding: 0;
    }
  </style>
</head>

<body>
  <article class="markdown-body">
    <h1 id="tp-refactoring-de-traitement-de-graphe"><a href="#tp-refactoring-de-traitement-de-graphe" class="anchor"></a>TP - Refactoring de traitement de graphe</h1><h2 id="introduction"><a href="#introduction" class="anchor"></a>Introduction</h2><p>Dans ce TP où l&#39;idée est de se mettre en situation où l&#39;on récupère un prototype à industrialiser, nous allons réfactorer une application qui charge un graphe et calcule le plus court chemin entre deux sommets.</p>
<p>L&#39;application se présente sous deux forme :</p>
<ul>
<li>Un utilitaire en ligne de commande</li>
<li>Une API basée sur <a href="https://spring.io/guides/gs/spring-boot/" target="_blank">spring boot</a></li>
</ul>
<p>Les objectifs sont les suivants :</p>
<ul>
<li>Rendre le code plus robuste</li>
<li>Optimiser le calcul de plus court chemin</li>
<li>Rendre le calcul de plus court chemin plus générique</li>
<li>Améliorer les entrées/sorties du programme</li>
</ul>
<p>Pour celà, nous allons faire une revue de code et procéder par étape.</p>
<h2 id="d-marrage"><a href="#d-marrage" class="anchor"></a>Démarrage</h2><ul>
<li>Forker le projet <a href="https://github.com/mborne/tp-refactoring-graph" target="_blank">https://github.com/mborne/tp-refactoring-graph</a></li>
<li>Cloner le fork</li>
<li>Lire le fichier <a href="https://github.com/mborne/tp-refactoring-graph#tp-refactoring-graph" target="_blank">README</a> pour :<ul>
<li>Découvrir l&#39;organisation du code</li>
<li>Construire le projet et exécuter les tests</li>
<li>Démarrer et tester l&#39;API</li>
</ul>
</li>
</ul>
<h2 id="mise-en-garde"><a href="#mise-en-garde" class="anchor"></a>Mise en garde</h2><p>Vous devrez impérativement livrer un code fonctionnel sur la branche par défaut de votre fork.</p>
<p>Pour ce faire, il vous est vivement conseillé de :</p>
<ul>
<li>Travailler sur une autre branche (ex : <code>develop</code>), en particulier si vous voulez pousser des travaux en cours.</li>
<li>Lancer à chaque étape la construction et les tests automatiques (<code>mvn clean package</code>).</li>
<li>Compléter ces tests automatique avec un test manuel sur l&#39;API.</li>
</ul>
<h2 id="0-x-blindage-de-la-construction-des-arcs"><a href="#0-x-blindage-de-la-construction-des-arcs" class="anchor"></a>0.x - Blindage de la construction des arcs</h2><p>On remarque que l&#39;on dispose d&#39;un modèle qui ne protège pas contre les erreurs la création des sommets et des arcs. Il est tout à fait possible de créer par erreur un <code>Edge</code> avec une <code>source</code> ou une <code>target</code> nulle.</p>
<p>On procède comme suit :</p>
<ul>
<li>Ajout d&#39;un constructeur <code>Edge(source: Vertex, target: Vertex)</code></li>
<li>Suppression du constructeur par défaut sur <code>Edge</code></li>
</ul>
<h2 id="0-x-ajout-de-fabriques-pour-les-sommets-et-les-arcs"><a href="#0-x-ajout-de-fabriques-pour-les-sommets-et-les-arcs" class="anchor"></a>0.x - Ajout de fabriques pour les sommets et les arcs</h2><p>En ajoutant un constructeur <code>Edge(source: Vertex, target: Vertex)</code>, on remarque que l&#39;on a simplifié la création des arcs et des sommets.</p>
<p>Toutefois, les opérations de création demeurent complexes et il reste la possibilité d&#39;oublier d&#39;ajouter les éléments aux listes de <code>vertices</code> et <code>edges</code> du graphe.</p>
<p>On va donc procéder comme suit :</p>
<ul>
<li>Ajout d&#39;une fabrique <code>createVertex(coordinate,id): Vertex</code> dans <code>Graph</code></li>
<li>Ajout d&#39;une fabrique <code>createEdge(source,target,id): Edge</code> dans <code>Graph</code></li>
<li>Masquage des constructeur <code>Vertex()</code> et <code>Edge(source,target)</code></li>
<li>Suppression de <code>Graph.setVertices(vertices)</code> et <code>Graph.setEdges(edges)</code></li>
</ul>
<p>Ainsi, on passera de :</p>
<pre><code class="language-java">Vertex a = new Vertex();
a.setId(&quot;a&quot;);
a.setCoordinate(new Coordinate(0.0, 0.0));
graph.getVertices().add(a);

Vertex b = new Vertex();
b.setId(&quot;b&quot;);
b.setCoordinate(new Coordinate(1.0, 0.0));
graph.getVertices().add(b);

Edge ab = new Edge(a,b);
ab.setId(&quot;ab&quot;);
graph.getEdges().add(ab);</code></pre>
<p>à</p>
<pre><code class="language-java">Vertex a = graph.createVertex(new Coordinate(0.0, 0.0),&quot;a&quot;);
Vertex b = graph.createVertex(new Coordinate(1.0, 0.0),&quot;b&quot;);
Edge ab  = graph.createEdge(a,b,&quot;ab&quot;);</code></pre>
<h2 id="0-x-indexation-des-arcs-entrants-et-sortant"><a href="#0-x-indexation-des-arcs-entrants-et-sortant" class="anchor"></a>0.x - Indexation des arcs entrants et sortant</h2><p>En lisant attentivement <code>DijsktraPathFinder</code> (ou un utilisant un outil tel VisualVM), on remarque que la méthode <code>graph.getOutEdges(vertex: Vertex)</code> est appelée très fréquemment dans la méthode <code>visit(vertex: Vertex)</code>.</p>
<p>Cette approche étant loin d&#39;être optimale, nous allons indexer les arcs sortants et entrants comme suit :</p>
<ul>
<li>Ajout des attributs <code>inEdges: List&lt;Edge&gt;</code> et <code>outEdges: List&lt;Edge&gt;</code> sur <code>Vertex</code>.</li>
<li>Ajout des getters <code>getInEdges(): Collection&lt;Edge&gt;</code> et  <code>getOutEdges(): Collection&lt;Edge&gt;</code> sur <code>Vertex</code></li>
<li>Remplissage automatique de <code>inEdges</code> et <code>outEdges</code> dans le constructeur <code>Edge(source,target)</code></li>
<li>Suppression de <code>setSource</code> et <code>setTarget</code> dans <code>Edge</code> (2)</li>
<li>Ré-écrire <code>Graph.getInEdges</code> et <code>Graph.getOutEdges</code> pour appeler <code>Vertex.getInEdges</code> et <code>Vertex.getOutEdges</code></li>
<li>Exclure <code>inEdges</code> et <code>outEdges</code> du rendu JSON au niveau de l&#39;API à l&#39;aide de l&#39;annotation <code>@JsonIgnore</code> (3).</li>
</ul>
<p>Remarques :</p>
<ul>
<li>(1) Nous n&#39;avons pas besoin pour l&#39;algorithme actuel des <code>inEdges</code> mais nous choisissons de conserver une symétrie dans le modèle.</li>
<li>(2) Nous n&#39;avons pas besoin d&#39;éditer les graphes après chargement, innutile de gérer la complexité pour <code>inEdges</code> et <code>outEdges</code>.</li>
<li>(3) ATTENTION : Sans cette étape, l&#39;API plantera avec une récursion infinie.</li>
</ul>
<h2 id="0-x-am-lioration-de-la-gestion-des-chemins-non-trouv-s"><a href="#0-x-am-lioration-de-la-gestion-des-chemins-non-trouv-s" class="anchor"></a>0.x - Amélioration de la gestion des chemins non trouvés</h2><p>On remarque que <code>findPath(Vertex origin, Vertex destination)</code> de <code>DijkstraPathFinder</code> renvoie <code>null</code> si le chemin n&#39;est pas trouvé, ce qui induit une réponse vide au niveau de l&#39;API.</p>
<p>On remarque que le cas où le sommet de départ ou d&#39;arrivé est mieux géré grâce :</p>
<ul>
<li>Au renvoi d&#39;une <code>NotFoundException</code> dans <code>Graph.findVertex(id: String)</code> dans le cas où le sommet n&#39;est pas trouvé par son identifiant</li>
<li>A la personnalisation du rendu des <code>NotFoundException</code> via <code>config.CustomErrorHandler</code></li>
</ul>
<p>Nous procédons de même en renvoyant une <code>NotFoundException</code> avec le modèle de message suivant dans <code>findPath(Vertex origin, Vertex destination)</code> de <code>DijkstraPathFinder</code> : <code>&quot;Path not found from &#39;%1s&#39; to &#39;%2s&#39;</code>.</p>
<h2 id="0-x-am-lioration-du-rendu-des-chemins"><a href="#0-x-am-lioration-du-rendu-des-chemins" class="anchor"></a>0.x - Amélioration du rendu des chemins</h2><p>Nous remarquons que la mise en forme des chemins est un peu pauvre au niveau de l&#39;API. Nous souhaitons produire un résultat sous forme d&#39;un objet JSON avec deux propriétés :</p>
<ul>
<li><code>edges</code>: La liste des arcs formant le chemin</li>
<li><code>length</code> : La somme des longueurs des <code>edges</code></li>
</ul>
<p>Pour ce faire, nous procédons ainsi :</p>
<ul>
<li>Ajout d&#39;un modèle <code>Path</code> encapsulant une liste de <code>Edge</code> nommée <code>edges</code>.</li>
<li>Ajout d&#39;une méthode <code>getLength()</code> à <code>Path</code> renvoyant la somme des longueurs des <code>edges</code>.</li>
<li>Renvoi d&#39;un <code>Path</code> dans <code>findPath</code> de <code>DijkstraPathFinder</code></li>
</ul>
<h2 id="0-x-cr-ation-d-39-un-mod-le-d-di-aux-noeuds-de-l-39-arbre-du-plus-court-chemin"><a href="#0-x-cr-ation-d-39-un-mod-le-d-di-aux-noeuds-de-l-39-arbre-du-plus-court-chemin" class="anchor"></a>0.x - Création d&#39;un modèle dédié aux noeuds de l&#39;arbre du plus court chemin</h2><p>On constate que <code>Vertex</code> est porteur de propriétés qui ne correspondent pas à un réseau routier mais à l&#39;algorithme de calcul du plus chemin : <code>cost</code>, <code>reachingEdge</code> et <code>visited</code>.</p>
<p>Ceci a un lourd impact sur l&#39;application : <strong>Il est en l&#39;état impossible de lancer en parallèle deux calculs de plus court chemin</strong> car il y a aura des conflits en édition sur les propriétés des <code>Vertex</code>.</p>
<p>Nous procédons dans un premier temps comme suit pour refondre <code>DijkstraPathFinder</code> en limitant les reprises de code à effectuer :</p>
<ul>
<li>Création d&#39;une classe <code>PathNode</code> correspondant à un noeud de l&#39;arbre</li>
<li>Migration des attributs <code>cost</code>, <code>reachingEdge</code> et <code>visited</code> de <code>Vertex</code> vers <code>PathNode</code></li>
<li>Ajout d&#39;une propriété <code>nodes: Map&lt;Vertex,PathNode&gt;</code> dans <code>DijkstraPathFinder</code></li>
<li>Mise à jour de <code>initGraph</code> dans <code>DijkstraPathFinder</code> pour initialiser <code>nodes</code></li>
<li>Ajout d&#39;une méthode utilitaire <code>getNode(vertex: Vertex): PathNode</code> dans <code>DijkstraPathFinder</code></li>
<li>Mise à jour du reste du code de la classe <code>DijkstraPathFinder</code> à l&#39;aide de <code>getNode</code></li>
</ul>
<h2 id="0-x-cr-ation-d-39-un-mod-le-d-di-l-39-arbre-du-plus-court-chemin"><a href="#0-x-cr-ation-d-39-un-mod-le-d-di-l-39-arbre-du-plus-court-chemin" class="anchor"></a>0.x - Création d&#39;un modèle dédié à l&#39;arbre du plus court chemin</h2><p>On encapsule <code>nodes: Map&lt;Vertex, PathNode&gt;</code> de <code>DijkstraPathFinder</code> sous forme d&#39;un arbre de plus court chemin nommé <code>PathTree</code> :</p>
<ul>
<li>Création de la classe <code>PathTree</code></li>
<li>Migration des éléments correspondant de <code>DisjktraPathFinder</code> vers <code>PathTree</code><ul>
<li><code>initGraph(origin)</code> devient <code>PathTree(graph: Graph, origin: Vertex)</code></li>
<li><code>buildPath(vertex)</code> devient <code>pathTree.getPath(destination)</code></li>
<li><code>getNode(vertex)</code> devient <code>pathTree.getNode(vertex)</code></li>
</ul>
</li>
</ul>
<h2 id="0-x-stockage-des-seuls-sommets-atteints-dans-pathtree"><a href="#0-x-stockage-des-seuls-sommets-atteints-dans-pathtree" class="anchor"></a>0.x - Stockage des seuls sommets atteints dans PathTree</h2><p>On remarque qu&#39;il est innutile de stocker des <code>PathNode</code> pour tous les sommets du graphe, qu&#39;il suffit d&#39;initialiser la liste des <code>nodes</code> avec l&#39;origine des chemins et de créer les <code>PathNode</code> quand on atteint de nouveaux sommets.</p>
<p>A l&#39;exception du test pour savoir si on a atteint la destination dans <code>DijkstraPathFinder</code>, les appels à <code>getNode</code> correspondent à des sommets atteints.</p>
<p>On procède donc comme suit :</p>
<ul>
<li>Ajout d&#39;une méthode <code>pathTree.isReached(destination)</code> pour clarifier <code>pathTree.getNode(destination).getReachingEdge() != null</code></li>
<li>Blindage de <code>pathTree.buildPath(destination)</code> dans le cas où le sommet n&#39;est pas atteint</li>
<li>Ajout d&#39;une méthode <code>getOrCreateNode(vertex)</code> dans <code>PathTree</code> et utilisation de cette méthode dans <code>DijkstraPathFinder</code></li>
<li>Reprise du constructeur <code>PathTree(graph, origin)</code> en <code>PathTree(origin)</code></li>
<li>Ajout de <code>pathTree.getReachedVertices(): Collection&lt;Vertex&gt;</code></li>
<li>Parcourt des seuls sommets atteints dans <code>findNextVertex</code></li>
<li>Suppression de l&#39;attribut <code>graph</code> désormais non utilisé dans <code>DijkstraPathFinder</code></li>
</ul>
<h2 id="0-x-pr-paration-de-la-mise-en-oeuvre-de-variantes-de-l-39-algorithme"><a href="#0-x-pr-paration-de-la-mise-en-oeuvre-de-variantes-de-l-39-algorithme" class="anchor"></a>0.x - Préparation de la mise en oeuvre de variantes de l&#39;algorithme</h2><p>Afin de préparer la mise en oeuvre de variante de l&#39;algorithme, on s&#39;efforce de bien identifier les différentes étapes de la construction de l&#39;arbre. Aussi, on veille à séparer la construction de l&#39;arbre de production du résultat en procédant comme suit dans <code>DijkstraPathFinder</code> :</p>
<ul>
<li>Extraction d&#39;une méthode <code>buildTree(destination)</code> dans <code>findPath</code></li>
</ul>
<h2 id="0-x-extraction-d-39-une-classe-pathtreebuilder-de-dijkstrapathfinder"><a href="#0-x-extraction-d-39-une-classe-pathtreebuilder-de-dijkstrapathfinder" class="anchor"></a>0.x - Extraction d&#39;une classe PathTreeBuilder de DijkstraPathFinder</h2><ul>
<li>Création d&#39;une classe <code>PathTreeBuilder</code> avec un constructeur <code>PathTreeBuilder(origin: Vertex)</code></li>
<li>Migration de <code>buildTree</code>, <code>visit</code> et <code>findNextVertex</code> de <code>DijkstraPathFinder</code> vers <code>PathTreeBuilder</code></li>
<li>Utilisation de <code>PathTreeBuilder</code> dans <code>DijkstraPathFinder</code></li>
</ul>
<h2 id="0-x-pr-paration-de-la-mise-en-place-d-39-une-strat-gie-de-calcul-du-plus-court-chemin"><a href="#0-x-pr-paration-de-la-mise-en-place-d-39-une-strat-gie-de-calcul-du-plus-court-chemin" class="anchor"></a>0.x - Préparation de la mise en place d&#39;une stratégie de calcul du plus court chemin</h2><p>Afin de pouvoir faire varier par la suite la méthode <code>findNextVertex</code> entre Dijkstra et A-star, on extrait une stratégie comme suit :</p>
<ul>
<li>Création d&#39;une interface <code>NextVertexFinder</code> avec une méthode <code>findNextVertex(pathTree: PathTree): Vertex</code></li>
<li>Implémentation de <code>DijkstraNextVertexFinder</code></li>
<li>Le constructeur <code>PathTreeBuilder(pathTree)</code> devient <code>PathTreeBuilder(nextVertexFinder, pathTree)</code></li>
</ul>
<h2 id="0-x-impl-mentation-de-a-star"><a href="#0-x-impl-mentation-de-a-star" class="anchor"></a>0.x - Implémentation de A-star</h2><p>On ajoute l&#39;implémentation de A-star comme suit :</p>
<ul>
<li>Modification de <code>findNextVertex(pathTree)</code> en <code>findNextVertex(pathTree,destination)</code> au niveau de l&#39;interface <code>NextVertexFinder</code></li>
<li>Ajout de <code>AStarNextVertexFinder</code> implémentant <code>NextVertexFinder</code></li>
</ul>
<p>Remarque : Dans le cas de A-star, <code>findNextVertex(pathTree,destination)</code> renverra le sommet atteint minimisant &quot;distance parcourue depuis l&#39;origine + distance à vol d&#39;oiseau pour atteindre la destination&quot;</p>
<h2 id="0-x-choix-de-la-strat-gie-de-calcul-dans-l-39-api"><a href="#0-x-choix-de-la-strat-gie-de-calcul-dans-l-39-api" class="anchor"></a>0.x - Choix de la stratégie de calcul dans l&#39;API</h2><p>On procède comme suit pour permettre le choix d&#39;une stratégie de calcul dans l&#39;API :</p>
<ul>
<li>Création d&#39;une fabrique <code>NextVertexFinderFactory.createNextVertexFinder(method: String)</code></li>
<li>Renommage de <code>DijkstraPathFinder</code> en <code>PathFinder</code></li>
<li>Ajout du paramètre <code>method: String</code> à <code>findPath</code> de <code>PathFinder</code></li>
<li>Ajout d&#39;un paramètre <code>method</code> à <code>findPath</code> dans <code>FindPathController</code></li>
</ul>
<h2 id="0-x-optimisation-du-chargement-du-graphe"><a href="#0-x-optimisation-du-chargement-du-graphe" class="anchor"></a>0.x - Optimisation du chargement du graphe</h2><p>En chargeant <a href="https://files.opendatarchives.fr/professionnels.ign.fr/route500/" target="_blank">ROUTE500 complet</a>, on observe un temps de chargement excessivement long. A l&#39;aide de VisualVM, on se rend compte que le programme passe le plus clair de son temps dans <code>GraphReader.getOrCreateVertex</code> faisant appel à <code>Graph.findVertex(coordinate: Coordinate)</code>.</p>
<p>En inspectant <code>Graph.findVertex(coordinate: Coordinate)</code>, on note un parcours complet des sommets à la recherche d&#39;une égalité stricte de coordonnée. Cette approche est loin d&#39;être optimale, nous pouvons optimiser en utilisant une <code>Map&lt;Coordinate, Vertex&gt;</code>.</p>
<h2 id="0-x-optimisation-du-temps-de-calcul"><a href="#0-x-optimisation-du-temps-de-calcul" class="anchor"></a>0.x - Optimisation du temps de calcul</h2><p>En lançant des calculs de plus court chemin sur le graphe ROUTE500 complet, on remarque un temps de calcul trop important. A l&#39;aide de VisualVM, on se rend compte que le programme passe le plus clair de son temps dans <code>findNextVertex</code>.</p>
<p>En regardant de plus près, on remarque que l&#39;on parcours l&#39;ensemble des sommets atteints pour filtrer ensuite les sommets déjà visités.</p>
<pre><code class="language-java">for (Vertex vertex : pathTree.getReachedVertices()) {
    PathNode node = pathTree.getNode(vertex);
    // sommet déjà visité?
    if (node.isVisited()) {
        continue;
    }
    //...</code></pre>
<p>On procède donc comme suit pour indexer les sommets non visité :</p>
<ul>
<li>Ajout de <code>notVisited: Set&lt;Vertex&gt;</code> sur <code>PathTree</code></li>
<li>Gestion de <code>notVisited</code> dans <code>getOrCreateNode</code> de <code>PathTree</code></li>
<li>Ajout de <code>getNotVisited(): Collection&lt;Vertex&gt;</code> sur <code>PathTree</code></li>
<li>Ajout de <code>markVisited(vertex)</code> sur <code>PathTree</code></li>
<li>Suppression de <code>visited</code> sur <code>PathNode</code></li>
<li>Mise à jour des codes pour utiliser <code>markVisited(vertex)</code> et <code>getNotVisited()</code></li>
</ul>

  </article>

  <script src="../assets/highlight/highlight.pack.js"></script>
  <script>hljs.initHighlightingOnLoad();</script>

  <script src="../assets/mermaid/mermaid.min.js"></script>
  <script>mermaid.init({
      startOnLoad: true,
      flowchart: {
        useMaxWidth: true
      }
    }, ".language-mermaid");</script>
</body>

</html>